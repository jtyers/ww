# watch implemented as a zsh function

function __ww_die() {
  echo "$@" >&2
  echo 1
}

# usage: watch [-n interval|-w] [--] cmd
function __ww() {
  usage="ww [-n <interval> | -w | -c <color> | --no-capture | -1] [--] cmd"

  interval=10
  once=0
  capture=1
  colour=""
  watch=0
  watch_wait=0.25
  watch_cmd="inotifywait -r -e modify -e close_write -e move -e move_self -e create -e delete -e delete_self ."

  O=`getopt -n ww -l no-capture,color:colour:interval:,once,watch,watch_wait -- Nc:n:1wW "$@"` || return $(__ww_die "$usage")
  eval set -- "$WW_DEFAULT_ARGS" "$O"
  while true; do
      case "$1" in
      -c|--color|--colour)	colour="$colour|${2}"; shift; shift; ;;
      -n|--interval)	interval="$2"; shift; shift; ;;
      -1|--once)	once=1; shift; ;;
      -N|--no-capture)	capture=0; shift; ;;
      -w|--watch)	watch=1; shift; ;;
      -W|--watch-wait)	watch_wait="$1"; shift; shift; ;;
      --)			shift; break;;
      *)			return $(__ww_die "$usage");;
      esac
  done

  [ $# -ge 1 ] || return $(__ww_die "$usage")
  cmdtorun="$@"

  if [ $capture -eq 0 ] && [ -n "$colour" ]; then
    echo "warning: --color has no effect when --no-capture is used" >&2
  fi

  cols=$(tput cols)
  lines=$(tput lines)
  ret=0

  # usage: <fgcolor> <bgcolor> <text>
  function printColouredString() {
    local fgcolor="$1"
    local bgcolor="$2"
    local text="$3"

    colsLeft=$(($cols - ${#text}))

    printf "$fgbold[$fgcolor]$bg[$bgcolor]" >&2
    printf "$text" >&2
    printf ' %.0s' {1..$colsLeft}
    printf "$reset_color" >&2
  
    tput el # clear to end of line
    printf '\n'
  }

  while true; do
    # re-evaluate on every run in case terminal has been resized
    cols=$(tput cols)
    lines=$(tput lines)

    printColouredString "white" "grey" "\`$cmdtorun\` running"
    tput cup 0 0 # move cursor to 0,0

    if [ $capture -eq 0 ]; then
      # no capture = run command and allow it to print direct to the terminal
      # ...in this mode no filtering/colouring will work
      tput clear
      printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` running in $interval secs"
      echo "" >&2
      eval $cmdtorun >&2

    else
      # https://stackoverflow.com/a/981831/1432488
      if [ -n "$colour" ]; then
        _output=$(eval $cmdtorun 2>&1)
        ret=$?
        output=$(grep -i --color=always -E "${colour}|$"<<<"$_output")

      else
        output=$(eval $cmdtorun 2>&1)
        ret=$?
      fi

      if [ $ret -eq 0 ]; then
        fgcol="grey"
        bgcol="green"
      else
        fgcol="grey"
        bgcol="red"
      fi

      tput clear
      printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` running in $interval secs"
      echo "" >&2
      echo "$output" >&2
    fi

    [ $ret -eq 0 ] && [ $once -eq 1 ] && break;
    
    tput cup 0 0 # move cursor to 0,0

    if [ $watch -eq 1 ]; then
      printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` watching for changes..."
      tput cup 0 0 # move cursor to 0,0
      eval "$watch_cmd" &>/dev/null

      # after a watch returns, wait a defined amount of time to allow for writes to complete etc
      # (and handle the case where the write we detect is in fact one of several files being 
      # written by another process)
      sleep $watch_wait 

    else
      cur=${interval}
      while [ $cur -gt 0 ]; do
        printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` running in $cur secs"
        tput cup 0 0 # move cursor to 0,0

        sleep 1
        (( cur-- ))
      done
    fi
  done
}

alias ww='__ww'
