# watch implemented as a zsh function

function __ww_die() {
  echo "$@" >&2
  echo 1
}

# usage: watch [-n interval|-w] [--] cmd
function __ww() {
  read -r -d '' usage <<EOF
ww - a better watch

USAGE
  ww [opts] [--] CMD

  --once, -1
    quit after CMD finishes successfully (exit code 0)

  --color, --colour, -c WORD
    highlight instances of WORD in output (can be repeated)

  --interval, -n N
    refresh every N seconds (ignored if -w is specified)

  --watch, -w
    refresh when files in the current directory are changed
    (requires inotifywatch to be installed)

  --watch-wait, -W SECONDS
    when --watch is used, ww will wait a short period after a
    change is detected to allow related I/O operations to complete
    (default: 0.25)

  --no-capture, -n
    allow underlying command to print straight to terminal rather
    than capturing output (used for slower commands, such as find,
    tail -f, etc; in this mode, --color has no effect)

  --until, -u
    wait until CMD has run successfully, then quit (this is just an
    alias for '--no-capture --once')

If WW_DEFAULT_ARGS is set, this can contain default arguments, processed before command line arguments on every invocation.

You can use any shell expansions or aliases in CMD, but remember to escape special characters (see EXAMPLES below).

Examples:
  ww df -h   # run df -h every 10 seconds

  # run 'go test' every 2 seconds, grepping for FAILED 
  # (note the escaped pipe character)
  ww -n 2 -- go test \| grep FAILED
  
  # run 'go test' every time files in the current directory
  # are changed
  ww -w -- go test
  
  # run 'ls ~/foo' continuously, if it fails, retry after 5 seconds, exit when it succeeds
  ww -u -n 5 -- ls ~/foo
EOF

  interval=10
  once=0
  capture=1
  colour=""
  watch=0
  watch_wait=0.25
  watch_cmd="inotifywait -r -e modify -e close_write -e move -e move_self -e create -e delete -e delete_self ."

  O=`getopt -n ww -l help,no-capture,color:colour:interval:,once,watch,watch-wait,until -- hNc:n:1wWu "$@"` || return $(__ww_die "$usage")
  eval set -- "$WW_DEFAULT_ARGS" "$O"
  while true; do
      case "$1" in
      -h|--help)	echo "$usage"; return 0 ;;
      -c|--color|--colour)	colour="$colour|${2}"; shift; shift; ;;
      -n|--interval)	interval="$2"; shift; shift; ;;
      -1|--once)	once=1; shift; ;;
      -N|--no-capture)	capture=0; shift; ;;
      -w|--watch)	watch=1; shift; ;;
      -W|--watch-wait)	watch_wait="$1"; shift; shift; ;;
      -u|--until)	capture=0; once=1; shift; ;;
      --)			shift; break;;
      *)			return $(__ww_die "$usage");;
      esac
  done

  [ $# -ge 1 ] || return $(__ww_die "$usage")
  cmdtorun="$@"

  if [ $capture -eq 0 ] && [ -n "$colour" ]; then
    echo "warning: --color has no effect when --no-capture is used" >&2
  fi

  cols=$(tput cols)
  lines=$(tput lines)
  ret=0

  # usage: <fgcolor> <bgcolor> <text>
  function printColouredString() {
    local fgcolor="$1"
    local bgcolor="$2"
    local text="$3"

    colsLeft=$(($cols - ${#text}))

    printf "$fgbold[$fgcolor]$bg[$bgcolor]" >&2
    printf "$text" >&2
    printf ' %.0s' {1..$colsLeft}
    printf "$reset_color" >&2
  
    tput el # clear to end of line
    printf '\n'
  }

  while true; do
    # re-evaluate on every run in case terminal has been resized
    cols=$(tput cols)
    lines=$(tput lines)
        
    fgcol="white"
    bgcol="grey"

    printColouredString "white" "grey" "\`$cmdtorun\` running"
    tput cup 0 0 # move cursor to 0,0

    if [ $capture -eq 0 ]; then
      # no capture = run command and allow it to print direct to the terminal
      # ...in this mode no filtering/colouring will work
      tput clear
      printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` running in $interval secs"
      echo "" >&2

      eval $cmdtorun >&2
      ret=$?

    else
      # https://stackoverflow.com/a/981831/1432488
      if [ -n "$colour" ]; then
        _output=$(eval $cmdtorun 2>&1)
        ret=$?
        output=$(grep -i --color=always -E "${colour}|$"<<<"$_output")

      else
        output=$(eval $cmdtorun 2>&1)
        ret=$?
      fi

      if [ $ret -eq 0 ]; then
        fgcol="grey"
        bgcol="green"
      else
        fgcol="grey"
        bgcol="red"
      fi

      tput clear
      printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` running in $interval secs"
      echo "" >&2
      echo "$output" >&2
    fi

    [ $ret -eq 0 ] && [ $once -eq 1 ] && break;
    
    tput cup 0 0 # move cursor to 0,0

    if [ $watch -eq 1 ]; then
      printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` watching for changes..."
      tput cup 0 0 # move cursor to 0,0
      eval "$watch_cmd" &>/dev/null

      # after a watch returns, wait a defined amount of time to allow for writes to complete etc
      # (and handle the case where the write we detect is in fact one of several files being 
      # written by another process)
      sleep $watch_wait 

    else
      cur=${interval}
      while [ $cur -gt 0 ]; do
        printColouredString "$fgcol" "$bgcol" "\`$cmdtorun\` running in $cur secs"
        tput cup 0 0 # move cursor to 0,0

        sleep 1
        (( cur-- ))
      done
    fi
  done
}

alias ww='__ww'
